{"ast":null,"code":"const cp = require('child_process');\n\nconst fs = require('fs-extra');\n\nconst path = require('path');\n\nconst util = require('util');\n/**\n * @constructor\n * @param {number} code Error code.\n * @param {string} message Error message.\n */\n\n\nfunction ProcessError(code, message) {\n  const callee = arguments.callee;\n  Error.apply(this, [message]);\n  Error.captureStackTrace(this, callee);\n  this.code = code;\n  this.message = message;\n  this.name = callee.name;\n}\n\nutil.inherits(ProcessError, Error);\n/**\n * Util function for handling spawned processes as promises.\n * @param {string} exe Executable.\n * @param {Array.<string>} args Arguments.\n * @param {string} cwd Working directory.\n * @return {Promise} A promise.\n */\n\nfunction spawn(exe, args, cwd) {\n  return new Promise((resolve, reject) => {\n    const child = cp.spawn(exe, args, {\n      cwd: cwd || process.cwd()\n    });\n    const buffer = [];\n    child.stderr.on('data', chunk => {\n      buffer.push(chunk.toString());\n    });\n    child.stdout.on('data', chunk => {\n      buffer.push(chunk.toString());\n    });\n    child.on('close', code => {\n      const output = buffer.join('');\n\n      if (code) {\n        const msg = output || 'Process failed: ' + code;\n        reject(new ProcessError(code, msg));\n      } else {\n        resolve(output);\n      }\n    });\n  });\n}\n/**\n * Create an object for executing git commands.\n * @param {string} cwd Repository directory.\n * @param {string} exe Git executable (full path if not already on path).\n * @constructor\n */\n\n\nfunction Git(cwd, cmd) {\n  this.cwd = cwd;\n  this.cmd = cmd || 'git';\n  this.output = '';\n}\n/**\n * Execute an arbitrary git command.\n * @param {string} var_args Arguments (e.g. 'remote', 'update').\n * @return {Promise} A promise.  The promise will be resolved with this instance\n *     or rejected with an error.\n */\n\n\nGit.prototype.exec = function () {\n  return spawn(this.cmd, [...arguments], this.cwd).then(output => {\n    this.output = output;\n    return this;\n  });\n};\n/**\n * Initialize repository.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.init = function () {\n  return this.exec('init');\n};\n/**\n * Clean up unversioned files.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.clean = function () {\n  return this.exec('clean', '-f', '-d');\n};\n/**\n * Hard reset to remote/branch\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.reset = function (remote, branch) {\n  return this.exec('reset', '--hard', remote + '/' + branch);\n};\n/**\n * Fetch from a remote.\n * @param {string} remote Remote alias.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.fetch = function (remote) {\n  return this.exec('fetch', remote);\n};\n/**\n * Checkout a branch (create an orphan if it doesn't exist on the remote).\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.checkout = function (remote, branch) {\n  const treeish = remote + '/' + branch;\n  return this.exec('ls-remote', '--exit-code', '.', treeish).then(() => {\n    // branch exists on remote, hard reset\n    return this.exec('checkout', branch).then(() => this.clean()).then(() => this.reset(remote, branch));\n  }, error => {\n    if (error instanceof ProcessError && error.code === 2) {\n      // branch doesn't exist, create an orphan\n      return this.exec('checkout', '--orphan', branch);\n    } else {\n      // unhandled error\n      throw error;\n    }\n  });\n};\n/**\n * Remove all unversioned files.\n * @param {string|string[]} files Files argument.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.rm = function (files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n\n  return this.exec('rm', '--ignore-unmatch', '-r', '-f', ...files);\n};\n/**\n * Add files.\n * @param {string|string[]} files Files argument.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.add = function (files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n\n  return this.exec('add', ...files);\n};\n/**\n * Commit (if there are any changes).\n * @param {string} message Commit message.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.commit = function (message) {\n  return this.exec('diff-index', '--quiet', 'HEAD').catch(() => this.exec('commit', '-m', message));\n};\n/**\n * Add tag\n * @param {string} name Name of tag.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.tag = function (name) {\n  return this.exec('tag', name);\n};\n/**\n * Push a branch.\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @param {boolean} force Force push.\n * @return {Promise} A promise.\n */\n\n\nGit.prototype.push = function (remote, branch, force) {\n  const args = ['push', '--tags', remote, branch];\n\n  if (force) {\n    args.push('--force');\n  }\n\n  return this.exec.apply(this, args);\n};\n/**\n * Get the URL for a remote.\n * @param {string} remote Remote alias.\n * @return {Promise<string>} A promise for the remote URL.\n */\n\n\nGit.prototype.getRemoteUrl = function (remote) {\n  return this.exec('config', '--get', 'remote.' + remote + '.url').then(git => {\n    const repo = git.output && git.output.split(/[\\n\\r]/).shift();\n\n    if (repo) {\n      return repo;\n    } else {\n      throw new Error('Failed to get repo URL from options or current directory.');\n    }\n  }).catch(err => {\n    throw new Error('Failed to get remote.' + remote + '.url (task must either be ' + 'run in a git repository with a configured ' + remote + ' remote ' + 'or must be configured with the \"repo\" option).');\n  });\n};\n/**\n * Delete ref to remove branch history\n * @param {string} branch\n */\n\n\nGit.prototype.deleteRef = function (branch) {\n  return this.exec('update-ref', '-d', 'refs/heads/' + branch);\n};\n/**\n * Clone a repo into the given dir if it doesn't already exist.\n * @param {string} repo Repository URL.\n * @param {string} dir Target directory.\n * @param {string} branch Branch name.\n * @param {options} options All options.\n * @return {Promise<Git>} A promise.\n */\n\n\nGit.clone = function clone(repo, dir, branch, options) {\n  return fs.exists(dir).then(exists => {\n    if (exists) {\n      return Promise.resolve(new Git(dir, options.git));\n    } else {\n      return fs.mkdirp(path.dirname(path.resolve(dir))).then(() => {\n        const args = ['clone', repo, dir, '--branch', branch, '--single-branch', '--origin', options.remote, '--depth', options.depth];\n        return spawn(options.git, args).catch(err => {\n          // try again without branch or depth options\n          return spawn(options.git, ['clone', repo, dir, '--origin', options.remote]);\n        }).then(() => new Git(dir, options.git));\n      });\n    }\n  });\n};\n\nmodule.exports = Git;","map":{"version":3,"sources":["C:/Users/tlvud/Desktop/react-web/pyp/node_modules/gh-pages/lib/git.js"],"names":["cp","require","fs","path","util","ProcessError","code","message","callee","arguments","Error","apply","captureStackTrace","name","inherits","spawn","exe","args","cwd","Promise","resolve","reject","child","process","buffer","stderr","on","chunk","push","toString","stdout","output","join","msg","Git","cmd","prototype","exec","then","init","clean","reset","remote","branch","fetch","checkout","treeish","error","rm","files","Array","isArray","add","commit","catch","tag","force","getRemoteUrl","git","repo","split","shift","err","deleteRef","clone","dir","options","exists","mkdirp","dirname","depth","module","exports"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,eAAD,CAAlB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,UAAD,CAAlB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASI,YAAT,CAAsBC,IAAtB,EAA4BC,OAA5B,EAAqC;AACnC,QAAMC,MAAM,GAAGC,SAAS,CAACD,MAAzB;AACAE,EAAAA,KAAK,CAACC,KAAN,CAAY,IAAZ,EAAkB,CAACJ,OAAD,CAAlB;AACAG,EAAAA,KAAK,CAACE,iBAAN,CAAwB,IAAxB,EAA8BJ,MAA9B;AACA,OAAKF,IAAL,GAAYA,IAAZ;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKM,IAAL,GAAYL,MAAM,CAACK,IAAnB;AACD;;AACDT,IAAI,CAACU,QAAL,CAAcT,YAAd,EAA4BK,KAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASK,KAAT,CAAeC,GAAf,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+B;AAC7B,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,KAAK,GAAGtB,EAAE,CAACe,KAAH,CAASC,GAAT,EAAcC,IAAd,EAAoB;AAACC,MAAAA,GAAG,EAAEA,GAAG,IAAIK,OAAO,CAACL,GAAR;AAAb,KAApB,CAAd;AACA,UAAMM,MAAM,GAAG,EAAf;AACAF,IAAAA,KAAK,CAACG,MAAN,CAAaC,EAAb,CAAgB,MAAhB,EAAwBC,KAAK,IAAI;AAC/BH,MAAAA,MAAM,CAACI,IAAP,CAAYD,KAAK,CAACE,QAAN,EAAZ;AACD,KAFD;AAGAP,IAAAA,KAAK,CAACQ,MAAN,CAAaJ,EAAb,CAAgB,MAAhB,EAAwBC,KAAK,IAAI;AAC/BH,MAAAA,MAAM,CAACI,IAAP,CAAYD,KAAK,CAACE,QAAN,EAAZ;AACD,KAFD;AAGAP,IAAAA,KAAK,CAACI,EAAN,CAAS,OAAT,EAAkBpB,IAAI,IAAI;AACxB,YAAMyB,MAAM,GAAGP,MAAM,CAACQ,IAAP,CAAY,EAAZ,CAAf;;AACA,UAAI1B,IAAJ,EAAU;AACR,cAAM2B,GAAG,GAAGF,MAAM,IAAI,qBAAqBzB,IAA3C;AACAe,QAAAA,MAAM,CAAC,IAAIhB,YAAJ,CAAiBC,IAAjB,EAAuB2B,GAAvB,CAAD,CAAN;AACD,OAHD,MAGO;AACLb,QAAAA,OAAO,CAACW,MAAD,CAAP;AACD;AACF,KARD;AASD,GAlBM,CAAP;AAmBD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,GAAT,CAAahB,GAAb,EAAkBiB,GAAlB,EAAuB;AACrB,OAAKjB,GAAL,GAAWA,GAAX;AACA,OAAKiB,GAAL,GAAWA,GAAG,IAAI,KAAlB;AACA,OAAKJ,MAAL,GAAc,EAAd;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAG,GAAG,CAACE,SAAJ,CAAcC,IAAd,GAAqB,YAAW;AAC9B,SAAOtB,KAAK,CAAC,KAAKoB,GAAN,EAAW,CAAC,GAAG1B,SAAJ,CAAX,EAA2B,KAAKS,GAAhC,CAAL,CAA0CoB,IAA1C,CAA+CP,MAAM,IAAI;AAC9D,SAAKA,MAAL,GAAcA,MAAd;AACA,WAAO,IAAP;AACD,GAHM,CAAP;AAID,CALD;AAOA;AACA;AACA;AACA;;;AACAG,GAAG,CAACE,SAAJ,CAAcG,IAAd,GAAqB,YAAW;AAC9B,SAAO,KAAKF,IAAL,CAAU,MAAV,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACAH,GAAG,CAACE,SAAJ,CAAcI,KAAd,GAAsB,YAAW;AAC/B,SAAO,KAAKH,IAAL,CAAU,OAAV,EAAmB,IAAnB,EAAyB,IAAzB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAH,GAAG,CAACE,SAAJ,CAAcK,KAAd,GAAsB,UAASC,MAAT,EAAiBC,MAAjB,EAAyB;AAC7C,SAAO,KAAKN,IAAL,CAAU,OAAV,EAAmB,QAAnB,EAA6BK,MAAM,GAAG,GAAT,GAAeC,MAA5C,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAT,GAAG,CAACE,SAAJ,CAAcQ,KAAd,GAAsB,UAASF,MAAT,EAAiB;AACrC,SAAO,KAAKL,IAAL,CAAU,OAAV,EAAmBK,MAAnB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAR,GAAG,CAACE,SAAJ,CAAcS,QAAd,GAAyB,UAASH,MAAT,EAAiBC,MAAjB,EAAyB;AAChD,QAAMG,OAAO,GAAGJ,MAAM,GAAG,GAAT,GAAeC,MAA/B;AACA,SAAO,KAAKN,IAAL,CAAU,WAAV,EAAuB,aAAvB,EAAsC,GAAtC,EAA2CS,OAA3C,EAAoDR,IAApD,CACL,MAAM;AACJ;AACA,WAAO,KAAKD,IAAL,CAAU,UAAV,EAAsBM,MAAtB,EACJL,IADI,CACC,MAAM,KAAKE,KAAL,EADP,EAEJF,IAFI,CAEC,MAAM,KAAKG,KAAL,CAAWC,MAAX,EAAmBC,MAAnB,CAFP,CAAP;AAGD,GANI,EAOLI,KAAK,IAAI;AACP,QAAIA,KAAK,YAAY1C,YAAjB,IAAiC0C,KAAK,CAACzC,IAAN,KAAe,CAApD,EAAuD;AACrD;AACA,aAAO,KAAK+B,IAAL,CAAU,UAAV,EAAsB,UAAtB,EAAkCM,MAAlC,CAAP;AACD,KAHD,MAGO;AACL;AACA,YAAMI,KAAN;AACD;AACF,GAfI,CAAP;AAiBD,CAnBD;AAqBA;AACA;AACA;AACA;AACA;;;AACAb,GAAG,CAACE,SAAJ,CAAcY,EAAd,GAAmB,UAASC,KAAT,EAAgB;AACjC,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAL,EAA2B;AACzBA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;;AACD,SAAO,KAAKZ,IAAL,CAAU,IAAV,EAAgB,kBAAhB,EAAoC,IAApC,EAA0C,IAA1C,EAAgD,GAAGY,KAAnD,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;;;AACAf,GAAG,CAACE,SAAJ,CAAcgB,GAAd,GAAoB,UAASH,KAAT,EAAgB;AAClC,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAL,EAA2B;AACzBA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;;AACD,SAAO,KAAKZ,IAAL,CAAU,KAAV,EAAiB,GAAGY,KAApB,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;;;AACAf,GAAG,CAACE,SAAJ,CAAciB,MAAd,GAAuB,UAAS9C,OAAT,EAAkB;AACvC,SAAO,KAAK8B,IAAL,CAAU,YAAV,EAAwB,SAAxB,EAAmC,MAAnC,EAA2CiB,KAA3C,CAAiD,MACtD,KAAKjB,IAAL,CAAU,QAAV,EAAoB,IAApB,EAA0B9B,OAA1B,CADK,CAAP;AAGD,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA2B,GAAG,CAACE,SAAJ,CAAcmB,GAAd,GAAoB,UAAS1C,IAAT,EAAe;AACjC,SAAO,KAAKwB,IAAL,CAAU,KAAV,EAAiBxB,IAAjB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAqB,GAAG,CAACE,SAAJ,CAAcR,IAAd,GAAqB,UAASc,MAAT,EAAiBC,MAAjB,EAAyBa,KAAzB,EAAgC;AACnD,QAAMvC,IAAI,GAAG,CAAC,MAAD,EAAS,QAAT,EAAmByB,MAAnB,EAA2BC,MAA3B,CAAb;;AACA,MAAIa,KAAJ,EAAW;AACTvC,IAAAA,IAAI,CAACW,IAAL,CAAU,SAAV;AACD;;AACD,SAAO,KAAKS,IAAL,CAAU1B,KAAV,CAAgB,IAAhB,EAAsBM,IAAtB,CAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACAiB,GAAG,CAACE,SAAJ,CAAcqB,YAAd,GAA6B,UAASf,MAAT,EAAiB;AAC5C,SAAO,KAAKL,IAAL,CAAU,QAAV,EAAoB,OAApB,EAA6B,YAAYK,MAAZ,GAAqB,MAAlD,EACJJ,IADI,CACCoB,GAAG,IAAI;AACX,UAAMC,IAAI,GAAGD,GAAG,CAAC3B,MAAJ,IAAc2B,GAAG,CAAC3B,MAAJ,CAAW6B,KAAX,CAAiB,QAAjB,EAA2BC,KAA3B,EAA3B;;AACA,QAAIF,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIjD,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF,GAVI,EAWJ4C,KAXI,CAWEQ,GAAG,IAAI;AACZ,UAAM,IAAIpD,KAAJ,CACJ,0BACEgC,MADF,GAEE,4BAFF,GAGE,4CAHF,GAIEA,MAJF,GAKE,UALF,GAME,gDAPE,CAAN;AASD,GArBI,CAAP;AAsBD,CAvBD;AAyBA;AACA;AACA;AACA;;;AACAR,GAAG,CAACE,SAAJ,CAAc2B,SAAd,GAA0B,UAASpB,MAAT,EAAiB;AACzC,SAAO,KAAKN,IAAL,CAAU,YAAV,EAAwB,IAAxB,EAA8B,gBAAgBM,MAA9C,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAT,GAAG,CAAC8B,KAAJ,GAAY,SAASA,KAAT,CAAeL,IAAf,EAAqBM,GAArB,EAA0BtB,MAA1B,EAAkCuB,OAAlC,EAA2C;AACrD,SAAOhE,EAAE,CAACiE,MAAH,CAAUF,GAAV,EAAe3B,IAAf,CAAoB6B,MAAM,IAAI;AACnC,QAAIA,MAAJ,EAAY;AACV,aAAOhD,OAAO,CAACC,OAAR,CAAgB,IAAIc,GAAJ,CAAQ+B,GAAR,EAAaC,OAAO,CAACR,GAArB,CAAhB,CAAP;AACD,KAFD,MAEO;AACL,aAAOxD,EAAE,CAACkE,MAAH,CAAUjE,IAAI,CAACkE,OAAL,CAAalE,IAAI,CAACiB,OAAL,CAAa6C,GAAb,CAAb,CAAV,EAA2C3B,IAA3C,CAAgD,MAAM;AAC3D,cAAMrB,IAAI,GAAG,CACX,OADW,EAEX0C,IAFW,EAGXM,GAHW,EAIX,UAJW,EAKXtB,MALW,EAMX,iBANW,EAOX,UAPW,EAQXuB,OAAO,CAACxB,MARG,EASX,SATW,EAUXwB,OAAO,CAACI,KAVG,CAAb;AAYA,eAAOvD,KAAK,CAACmD,OAAO,CAACR,GAAT,EAAczC,IAAd,CAAL,CACJqC,KADI,CACEQ,GAAG,IAAI;AACZ;AACA,iBAAO/C,KAAK,CAACmD,OAAO,CAACR,GAAT,EAAc,CACxB,OADwB,EAExBC,IAFwB,EAGxBM,GAHwB,EAIxB,UAJwB,EAKxBC,OAAO,CAACxB,MALgB,CAAd,CAAZ;AAOD,SAVI,EAWJJ,IAXI,CAWC,MAAM,IAAIJ,GAAJ,CAAQ+B,GAAR,EAAaC,OAAO,CAACR,GAArB,CAXP,CAAP;AAYD,OAzBM,CAAP;AA0BD;AACF,GA/BM,CAAP;AAgCD,CAjCD;;AAmCAa,MAAM,CAACC,OAAP,GAAiBtC,GAAjB","sourcesContent":["const cp = require('child_process');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst util = require('util');\n\n/**\n * @constructor\n * @param {number} code Error code.\n * @param {string} message Error message.\n */\nfunction ProcessError(code, message) {\n  const callee = arguments.callee;\n  Error.apply(this, [message]);\n  Error.captureStackTrace(this, callee);\n  this.code = code;\n  this.message = message;\n  this.name = callee.name;\n}\nutil.inherits(ProcessError, Error);\n\n/**\n * Util function for handling spawned processes as promises.\n * @param {string} exe Executable.\n * @param {Array.<string>} args Arguments.\n * @param {string} cwd Working directory.\n * @return {Promise} A promise.\n */\nfunction spawn(exe, args, cwd) {\n  return new Promise((resolve, reject) => {\n    const child = cp.spawn(exe, args, {cwd: cwd || process.cwd()});\n    const buffer = [];\n    child.stderr.on('data', chunk => {\n      buffer.push(chunk.toString());\n    });\n    child.stdout.on('data', chunk => {\n      buffer.push(chunk.toString());\n    });\n    child.on('close', code => {\n      const output = buffer.join('');\n      if (code) {\n        const msg = output || 'Process failed: ' + code;\n        reject(new ProcessError(code, msg));\n      } else {\n        resolve(output);\n      }\n    });\n  });\n}\n\n/**\n * Create an object for executing git commands.\n * @param {string} cwd Repository directory.\n * @param {string} exe Git executable (full path if not already on path).\n * @constructor\n */\nfunction Git(cwd, cmd) {\n  this.cwd = cwd;\n  this.cmd = cmd || 'git';\n  this.output = '';\n}\n\n/**\n * Execute an arbitrary git command.\n * @param {string} var_args Arguments (e.g. 'remote', 'update').\n * @return {Promise} A promise.  The promise will be resolved with this instance\n *     or rejected with an error.\n */\nGit.prototype.exec = function() {\n  return spawn(this.cmd, [...arguments], this.cwd).then(output => {\n    this.output = output;\n    return this;\n  });\n};\n\n/**\n * Initialize repository.\n * @return {Promise} A promise.\n */\nGit.prototype.init = function() {\n  return this.exec('init');\n};\n\n/**\n * Clean up unversioned files.\n * @return {Promise} A promise.\n */\nGit.prototype.clean = function() {\n  return this.exec('clean', '-f', '-d');\n};\n\n/**\n * Hard reset to remote/branch\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\nGit.prototype.reset = function(remote, branch) {\n  return this.exec('reset', '--hard', remote + '/' + branch);\n};\n\n/**\n * Fetch from a remote.\n * @param {string} remote Remote alias.\n * @return {Promise} A promise.\n */\nGit.prototype.fetch = function(remote) {\n  return this.exec('fetch', remote);\n};\n\n/**\n * Checkout a branch (create an orphan if it doesn't exist on the remote).\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @return {Promise} A promise.\n */\nGit.prototype.checkout = function(remote, branch) {\n  const treeish = remote + '/' + branch;\n  return this.exec('ls-remote', '--exit-code', '.', treeish).then(\n    () => {\n      // branch exists on remote, hard reset\n      return this.exec('checkout', branch)\n        .then(() => this.clean())\n        .then(() => this.reset(remote, branch));\n    },\n    error => {\n      if (error instanceof ProcessError && error.code === 2) {\n        // branch doesn't exist, create an orphan\n        return this.exec('checkout', '--orphan', branch);\n      } else {\n        // unhandled error\n        throw error;\n      }\n    }\n  );\n};\n\n/**\n * Remove all unversioned files.\n * @param {string|string[]} files Files argument.\n * @return {Promise} A promise.\n */\nGit.prototype.rm = function(files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n  return this.exec('rm', '--ignore-unmatch', '-r', '-f', ...files);\n};\n\n/**\n * Add files.\n * @param {string|string[]} files Files argument.\n * @return {Promise} A promise.\n */\nGit.prototype.add = function(files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n  return this.exec('add', ...files);\n};\n\n/**\n * Commit (if there are any changes).\n * @param {string} message Commit message.\n * @return {Promise} A promise.\n */\nGit.prototype.commit = function(message) {\n  return this.exec('diff-index', '--quiet', 'HEAD').catch(() =>\n    this.exec('commit', '-m', message)\n  );\n};\n\n/**\n * Add tag\n * @param {string} name Name of tag.\n * @return {Promise} A promise.\n */\nGit.prototype.tag = function(name) {\n  return this.exec('tag', name);\n};\n\n/**\n * Push a branch.\n * @param {string} remote Remote alias.\n * @param {string} branch Branch name.\n * @param {boolean} force Force push.\n * @return {Promise} A promise.\n */\nGit.prototype.push = function(remote, branch, force) {\n  const args = ['push', '--tags', remote, branch];\n  if (force) {\n    args.push('--force');\n  }\n  return this.exec.apply(this, args);\n};\n\n/**\n * Get the URL for a remote.\n * @param {string} remote Remote alias.\n * @return {Promise<string>} A promise for the remote URL.\n */\nGit.prototype.getRemoteUrl = function(remote) {\n  return this.exec('config', '--get', 'remote.' + remote + '.url')\n    .then(git => {\n      const repo = git.output && git.output.split(/[\\n\\r]/).shift();\n      if (repo) {\n        return repo;\n      } else {\n        throw new Error(\n          'Failed to get repo URL from options or current directory.'\n        );\n      }\n    })\n    .catch(err => {\n      throw new Error(\n        'Failed to get remote.' +\n          remote +\n          '.url (task must either be ' +\n          'run in a git repository with a configured ' +\n          remote +\n          ' remote ' +\n          'or must be configured with the \"repo\" option).'\n      );\n    });\n};\n\n/**\n * Delete ref to remove branch history\n * @param {string} branch\n */\nGit.prototype.deleteRef = function(branch) {\n  return this.exec('update-ref', '-d', 'refs/heads/' + branch);\n};\n\n/**\n * Clone a repo into the given dir if it doesn't already exist.\n * @param {string} repo Repository URL.\n * @param {string} dir Target directory.\n * @param {string} branch Branch name.\n * @param {options} options All options.\n * @return {Promise<Git>} A promise.\n */\nGit.clone = function clone(repo, dir, branch, options) {\n  return fs.exists(dir).then(exists => {\n    if (exists) {\n      return Promise.resolve(new Git(dir, options.git));\n    } else {\n      return fs.mkdirp(path.dirname(path.resolve(dir))).then(() => {\n        const args = [\n          'clone',\n          repo,\n          dir,\n          '--branch',\n          branch,\n          '--single-branch',\n          '--origin',\n          options.remote,\n          '--depth',\n          options.depth\n        ];\n        return spawn(options.git, args)\n          .catch(err => {\n            // try again without branch or depth options\n            return spawn(options.git, [\n              'clone',\n              repo,\n              dir,\n              '--origin',\n              options.remote\n            ]);\n          })\n          .then(() => new Git(dir, options.git));\n      });\n    }\n  });\n};\n\nmodule.exports = Git;\n"]},"metadata":{},"sourceType":"script"}