{"ast":null,"code":"const path = require('path');\n\nconst Git = require('./git');\n\nconst async = require('async');\n\nconst fs = require('fs-extra');\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths.\n */\n\n\nconst uniqueDirs = exports.uniqueDirs = function (files) {\n  const dirs = {};\n  files.forEach(filepath => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs[partial] = true;\n\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs[partial] = true;\n    }\n  });\n  return Object.keys(dirs);\n};\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\n\n\nconst byShortPath = exports.byShortPath = (a, b) => {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n\n  return cmp;\n};\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths ordered by path length.\n */\n\n\nconst dirsToCreate = exports.dirsToCreate = function (files) {\n  return uniqueDirs(files).sort(byShortPath);\n};\n/**\n * Copy a file.\n * @param {Object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\n\n\nconst copyFile = exports.copyFile = function (obj, callback) {\n  let called = false;\n\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', err => {\n    done(err);\n  });\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', err => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n  read.pipe(write);\n};\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\n\n\nfunction makeDir(path, callback) {\n  fs.mkdir(path, err => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n/**\n * Copy a list of files.\n * @param {Array.<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\n\n\nexports.copy = function (files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach(file => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n    async.eachSeries(dirsToCreate(destFiles), makeDir, err => {\n      if (err) {\n        return reject(err);\n      }\n\n      async.each(pairs, copyFile, err => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function (cwd) {\n  return Promise.all([new Git(cwd).exec('config', 'user.name'), new Git(cwd).exec('config', 'user.email')]).then(results => {\n    return {\n      name: results[0].output.trim(),\n      email: results[1].output.trim()\n    };\n  }).catch(err => {\n    // git config exits with 1 if name or email is not set\n    return null;\n  });\n};","map":{"version":3,"sources":["C:/Users/tlvud/Desktop/react-web/pyp/node_modules/gh-pages/lib/util.js"],"names":["path","require","Git","async","fs","uniqueDirs","exports","files","dirs","forEach","filepath","parts","dirname","split","sep","partial","i","ii","length","join","Object","keys","byShortPath","a","b","aParts","bParts","aLength","bLength","cmp","aPart","bPart","dirsToCreate","sort","copyFile","obj","callback","called","done","err","read","createReadStream","src","on","write","createWriteStream","dest","pipe","makeDir","mkdir","stat","err2","isDirectory","copy","base","Promise","resolve","reject","pairs","destFiles","file","relative","target","push","eachSeries","each","getUser","cwd","all","exec","then","results","name","output","trim","email","catch"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,UAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,UAAU,GAAIC,OAAO,CAACD,UAAR,GAAqB,UAASE,KAAT,EAAgB;AACvD,QAAMC,IAAI,GAAG,EAAb;AACAD,EAAAA,KAAK,CAACE,OAAN,CAAcC,QAAQ,IAAI;AACxB,UAAMC,KAAK,GAAGX,IAAI,CAACY,OAAL,CAAaF,QAAb,EAAuBG,KAAvB,CAA6Bb,IAAI,CAACc,GAAlC,CAAd;AACA,QAAIC,OAAO,GAAGJ,KAAK,CAAC,CAAD,CAAL,IAAY,GAA1B;AACAH,IAAAA,IAAI,CAACO,OAAD,CAAJ,GAAgB,IAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGN,KAAK,CAACO,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;AAC9CD,MAAAA,OAAO,GAAGf,IAAI,CAACmB,IAAL,CAAUJ,OAAV,EAAmBJ,KAAK,CAACK,CAAD,CAAxB,CAAV;AACAR,MAAAA,IAAI,CAACO,OAAD,CAAJ,GAAgB,IAAhB;AACD;AACF,GARD;AASA,SAAOK,MAAM,CAACC,IAAP,CAAYb,IAAZ,CAAP;AACD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMc,WAAW,GAAIhB,OAAO,CAACgB,WAAR,GAAsB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACnD,QAAMC,MAAM,GAAGF,CAAC,CAACV,KAAF,CAAQb,IAAI,CAACc,GAAb,CAAf;AACA,QAAMY,MAAM,GAAGF,CAAC,CAACX,KAAF,CAAQb,IAAI,CAACc,GAAb,CAAf;AACA,QAAMa,OAAO,GAAGF,MAAM,CAACP,MAAvB;AACA,QAAMU,OAAO,GAAGF,MAAM,CAACR,MAAvB;AACA,MAAIW,GAAG,GAAG,CAAV;;AACA,MAAIF,OAAO,GAAGC,OAAd,EAAuB;AACrBC,IAAAA,GAAG,GAAG,CAAC,CAAP;AACD,GAFD,MAEO,IAAIF,OAAO,GAAGC,OAAd,EAAuB;AAC5BC,IAAAA,GAAG,GAAG,CAAN;AACD,GAFM,MAEA;AACL,QAAIC,KAAJ,EAAWC,KAAX;;AACA,SAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,OAApB,EAA6B,EAAEX,CAA/B,EAAkC;AAChCc,MAAAA,KAAK,GAAGL,MAAM,CAACT,CAAD,CAAd;AACAe,MAAAA,KAAK,GAAGL,MAAM,CAACV,CAAD,CAAd;;AACA,UAAIc,KAAK,GAAGC,KAAZ,EAAmB;AACjBF,QAAAA,GAAG,GAAG,CAAC,CAAP;AACA;AACD,OAHD,MAGO,IAAIC,KAAK,GAAGC,KAAZ,EAAmB;AACxBF,QAAAA,GAAG,GAAG,CAAN;AACA;AACD;AACF;AACF;;AACD,SAAOA,GAAP;AACD,CAzBD;AA2BA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,YAAY,GAAI1B,OAAO,CAAC0B,YAAR,GAAuB,UAASzB,KAAT,EAAgB;AAC3D,SAAOF,UAAU,CAACE,KAAD,CAAV,CAAkB0B,IAAlB,CAAuBX,WAAvB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA,MAAMY,QAAQ,GAAI5B,OAAO,CAAC4B,QAAR,GAAmB,UAASC,GAAT,EAAcC,QAAd,EAAwB;AAC3D,MAAIC,MAAM,GAAG,KAAb;;AACA,WAASC,IAAT,CAAcC,GAAd,EAAmB;AACjB,QAAI,CAACF,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,IAAT;AACAD,MAAAA,QAAQ,CAACG,GAAD,CAAR;AACD;AACF;;AAED,QAAMC,IAAI,GAAGpC,EAAE,CAACqC,gBAAH,CAAoBN,GAAG,CAACO,GAAxB,CAAb;AACAF,EAAAA,IAAI,CAACG,EAAL,CAAQ,OAAR,EAAiBJ,GAAG,IAAI;AACtBD,IAAAA,IAAI,CAACC,GAAD,CAAJ;AACD,GAFD;AAIA,QAAMK,KAAK,GAAGxC,EAAE,CAACyC,iBAAH,CAAqBV,GAAG,CAACW,IAAzB,CAAd;AACAF,EAAAA,KAAK,CAACD,EAAN,CAAS,OAAT,EAAkBJ,GAAG,IAAI;AACvBD,IAAAA,IAAI,CAACC,GAAD,CAAJ;AACD,GAFD;AAGAK,EAAAA,KAAK,CAACD,EAAN,CAAS,OAAT,EAAkB,MAAM;AACtBL,IAAAA,IAAI;AACL,GAFD;AAIAE,EAAAA,IAAI,CAACO,IAAL,CAAUH,KAAV;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;;;AACA,SAASI,OAAT,CAAiBhD,IAAjB,EAAuBoC,QAAvB,EAAiC;AAC/BhC,EAAAA,EAAE,CAAC6C,KAAH,CAASjD,IAAT,EAAeuC,GAAG,IAAI;AACpB,QAAIA,GAAJ,EAAS;AACP;AACAnC,MAAAA,EAAE,CAAC8C,IAAH,CAAQlD,IAAR,EAAc,CAACmD,IAAD,EAAOD,IAAP,KAAgB;AAC5B,YAAIC,IAAI,IAAI,CAACD,IAAI,CAACE,WAAL,EAAb,EAAiC;AAC/BhB,UAAAA,QAAQ,CAACG,GAAD,CAAR;AACD,SAFD,MAEO;AACLH,UAAAA,QAAQ;AACT;AACF,OAND;AAOD,KATD,MASO;AACLA,MAAAA,QAAQ;AACT;AACF,GAbD;AAcD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9B,OAAO,CAAC+C,IAAR,GAAe,UAAS9C,KAAT,EAAgB+C,IAAhB,EAAsBR,IAAtB,EAA4B;AACzC,SAAO,IAAIS,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,KAAK,GAAG,EAAd;AACA,UAAMC,SAAS,GAAG,EAAlB;AACApD,IAAAA,KAAK,CAACE,OAAN,CAAcmD,IAAI,IAAI;AACpB,YAAMlB,GAAG,GAAG1C,IAAI,CAACwD,OAAL,CAAaF,IAAb,EAAmBM,IAAnB,CAAZ;AACA,YAAMC,QAAQ,GAAG7D,IAAI,CAAC6D,QAAL,CAAcP,IAAd,EAAoBZ,GAApB,CAAjB;AACA,YAAMoB,MAAM,GAAG9D,IAAI,CAACmB,IAAL,CAAU2B,IAAV,EAAgBe,QAAhB,CAAf;AACAH,MAAAA,KAAK,CAACK,IAAN,CAAW;AACTrB,QAAAA,GAAG,EAAEA,GADI;AAETI,QAAAA,IAAI,EAAEgB;AAFG,OAAX;AAIAH,MAAAA,SAAS,CAACI,IAAV,CAAeD,MAAf;AACD,KATD;AAWA3D,IAAAA,KAAK,CAAC6D,UAAN,CAAiBhC,YAAY,CAAC2B,SAAD,CAA7B,EAA0CX,OAA1C,EAAmDT,GAAG,IAAI;AACxD,UAAIA,GAAJ,EAAS;AACP,eAAOkB,MAAM,CAAClB,GAAD,CAAb;AACD;;AACDpC,MAAAA,KAAK,CAAC8D,IAAN,CAAWP,KAAX,EAAkBxB,QAAlB,EAA4BK,GAAG,IAAI;AACjC,YAAIA,GAAJ,EAAS;AACP,iBAAOkB,MAAM,CAAClB,GAAD,CAAb;AACD,SAFD,MAEO;AACL,iBAAOiB,OAAO,EAAd;AACD;AACF,OAND;AAOD,KAXD;AAYD,GA1BM,CAAP;AA2BD,CA5BD;;AA8BAlD,OAAO,CAAC4D,OAAR,GAAkB,UAASC,GAAT,EAAc;AAC9B,SAAOZ,OAAO,CAACa,GAAR,CAAY,CACjB,IAAIlE,GAAJ,CAAQiE,GAAR,EAAaE,IAAb,CAAkB,QAAlB,EAA4B,WAA5B,CADiB,EAEjB,IAAInE,GAAJ,CAAQiE,GAAR,EAAaE,IAAb,CAAkB,QAAlB,EAA4B,YAA5B,CAFiB,CAAZ,EAIJC,IAJI,CAICC,OAAO,IAAI;AACf,WAAO;AAACC,MAAAA,IAAI,EAAED,OAAO,CAAC,CAAD,CAAP,CAAWE,MAAX,CAAkBC,IAAlB,EAAP;AAAiCC,MAAAA,KAAK,EAAEJ,OAAO,CAAC,CAAD,CAAP,CAAWE,MAAX,CAAkBC,IAAlB;AAAxC,KAAP;AACD,GANI,EAOJE,KAPI,CAOErC,GAAG,IAAI;AACZ;AACA,WAAO,IAAP;AACD,GAVI,CAAP;AAWD,CAZD","sourcesContent":["const path = require('path');\nconst Git = require('./git');\nconst async = require('async');\nconst fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths.\n */\nconst uniqueDirs = (exports.uniqueDirs = function(files) {\n  const dirs = {};\n  files.forEach(filepath => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs[partial] = true;\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs[partial] = true;\n    }\n  });\n  return Object.keys(dirs);\n});\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nconst byShortPath = (exports.byShortPath = (a, b) => {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n});\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths ordered by path length.\n */\nconst dirsToCreate = (exports.dirsToCreate = function(files) {\n  return uniqueDirs(files).sort(byShortPath);\n});\n\n/**\n * Copy a file.\n * @param {Object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nconst copyFile = (exports.copyFile = function(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', err => {\n    done(err);\n  });\n\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', err => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n\n  read.pipe(write);\n});\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, err => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array.<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function(files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach(file => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n\n    async.eachSeries(dirsToCreate(destFiles), makeDir, err => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, err => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function(cwd) {\n  return Promise.all([\n    new Git(cwd).exec('config', 'user.name'),\n    new Git(cwd).exec('config', 'user.email')\n  ])\n    .then(results => {\n      return {name: results[0].output.trim(), email: results[1].output.trim()};\n    })\n    .catch(err => {\n      // git config exits with 1 if name or email is not set\n      return null;\n    });\n};\n"]},"metadata":{},"sourceType":"script"}